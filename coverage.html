
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kizmey/order_management_system/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/kizmey/order_management_system/database/migration/migration.go (0.0%)</option>
				
				<option value="file2">github.com/kizmey/order_management_system/database/postgres.go (0.0%)</option>
				
				<option value="file3">github.com/kizmey/order_management_system/main.go (0.0%)</option>
				
				<option value="file4">github.com/kizmey/order_management_system/observability/logs/logger.go (0.0%)</option>
				
				<option value="file5">github.com/kizmey/order_management_system/observability/metrics.go (0.0%)</option>
				
				<option value="file6">github.com/kizmey/order_management_system/observability/tracer/customTracer.go (20.0%)</option>
				
				<option value="file7">github.com/kizmey/order_management_system/pkg/controller/order/orderControllerImpl.go (0.0%)</option>
				
				<option value="file8">github.com/kizmey/order_management_system/pkg/controller/product/productControllerImpl.go (0.0%)</option>
				
				<option value="file9">github.com/kizmey/order_management_system/pkg/controller/stock/stockControllerImpl.go (0.0%)</option>
				
				<option value="file10">github.com/kizmey/order_management_system/pkg/controller/transaction/transactionContrllerImpl.go (0.0%)</option>
				
				<option value="file11">github.com/kizmey/order_management_system/pkg/interface/aggregation/ecommerce.go (100.0%)</option>
				
				<option value="file12">github.com/kizmey/order_management_system/pkg/interface/aggregation/transactionEcommerce.go (100.0%)</option>
				
				<option value="file13">github.com/kizmey/order_management_system/pkg/interface/entities/order.go (100.0%)</option>
				
				<option value="file14">github.com/kizmey/order_management_system/pkg/interface/model/order.go (0.0%)</option>
				
				<option value="file15">github.com/kizmey/order_management_system/pkg/interface/model/product.go (0.0%)</option>
				
				<option value="file16">github.com/kizmey/order_management_system/pkg/interface/model/stock.go (0.0%)</option>
				
				<option value="file17">github.com/kizmey/order_management_system/pkg/interface/model/transaction.go (0.0%)</option>
				
				<option value="file18">github.com/kizmey/order_management_system/pkg/repository/order/orderRepositoryImpl.go (0.0%)</option>
				
				<option value="file19">github.com/kizmey/order_management_system/pkg/repository/order/orderRepositoryMock.go (92.3%)</option>
				
				<option value="file20">github.com/kizmey/order_management_system/pkg/repository/product/productRepositoryImpl.go (0.0%)</option>
				
				<option value="file21">github.com/kizmey/order_management_system/pkg/repository/product/productRepositoryMock.go (95.2%)</option>
				
				<option value="file22">github.com/kizmey/order_management_system/pkg/repository/stock/stockRepositoryImpl.go (0.0%)</option>
				
				<option value="file23">github.com/kizmey/order_management_system/pkg/repository/stock/stockRepositoryMock.go (90.9%)</option>
				
				<option value="file24">github.com/kizmey/order_management_system/pkg/repository/transaction/transactionRepositoryImpl.go (0.0%)</option>
				
				<option value="file25">github.com/kizmey/order_management_system/pkg/repository/transaction/transactionRepositoryMock.go (92.3%)</option>
				
				<option value="file26">github.com/kizmey/order_management_system/pkg/service/order/orderServiceImpl.go (97.9%)</option>
				
				<option value="file27">github.com/kizmey/order_management_system/pkg/service/product/productServiceImpl.go (100.0%)</option>
				
				<option value="file28">github.com/kizmey/order_management_system/pkg/service/stock/stockServiceImpl.go (100.0%)</option>
				
				<option value="file29">github.com/kizmey/order_management_system/pkg/service/transaction/transactionServiceImpl.go (100.0%)</option>
				
				<option value="file30">github.com/kizmey/order_management_system/pkg/usecase.go (0.0%)</option>
				
				<option value="file31">github.com/kizmey/order_management_system/server/httpEchoServer/custom/error.go (0.0%)</option>
				
				<option value="file32">github.com/kizmey/order_management_system/server/httpEchoServer/custom/paramid.go (0.0%)</option>
				
				<option value="file33">github.com/kizmey/order_management_system/server/httpEchoServer/custom/request.go (0.0%)</option>
				
				<option value="file34">github.com/kizmey/order_management_system/server/httpEchoServer/echoServer.go (0.0%)</option>
				
				<option value="file35">github.com/kizmey/order_management_system/server/httpEchoServer/middleware/loggerMiddleware.go (0.0%)</option>
				
				<option value="file36">github.com/kizmey/order_management_system/server/httpEchoServer/middleware/tracingMiddleware.go (0.0%)</option>
				
				<option value="file37">github.com/kizmey/order_management_system/server/httpEchoServer/orderRoute.go (0.0%)</option>
				
				<option value="file38">github.com/kizmey/order_management_system/server/httpEchoServer/productRoute.go (0.0%)</option>
				
				<option value="file39">github.com/kizmey/order_management_system/server/httpEchoServer/stockRoute.go (0.0%)</option>
				
				<option value="file40">github.com/kizmey/order_management_system/server/httpEchoServer/transactionRoute.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "github.com/go-playground/validator/v10"
        "strings"
        "time"

        "github.com/spf13/viper"
)

type (
        Database struct {
                Host     string `mapstructure:"host" validate:"required"`
                Port     int    `mapstructure:"port" validate:"required"`
                User     string `mapstructure:"user" validate:"required"`
                Password string `mapstructure:"password" validate:"required"`
                DBName   string `mapstructure:"dbname" validate:"required"`
                SSLMode  string `mapstructure:"sslmode" validate:"required"`
                Schema   string `mapstructure:"schema" validate:"required"`
        }

        Server struct {
                Port         int           `mapstructure:"port" validate:"required"`
                AllowOrigins []string      `mapstructure:"allowOrigins" validate:"required"`
                Timeout      time.Duration `mapstructure:"timeout" validate:"required"`
                BodyLimit    string        `mapstructure:"bodyLimit" validate:"required"`
        }

        Config struct {
                Database *Database `mapstructure:"database" validate:"required"`
                Server   *Server   `mapstructure:"server" validate:"required"`
        }
)

func GettingConfig() *Config <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath("./config")

        //comment for migration database
        //viper.AddConfigPath("../../config")

        viper.AutomaticEnv()
        viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

        configInstance := &amp;Config{}

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">if err := viper.Unmarshal(configInstance); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">validate := validator.New()

        if err := validate.Struct(configInstance); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return configInstance</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/kizmey/order_management_system/config"
        "github.com/kizmey/order_management_system/database"
        "github.com/kizmey/order_management_system/pkg/interface/model"
        "gorm.io/gorm"
)

func main() <span class="cov0" title="0">{
        conf := config.GettingConfig()
        db := database.NewPostgresDatabase(conf.Database)

        tx := db.Connect().Begin()

        productMigration(tx)
        stockMigration(tx)
        transactionMigration(tx)
        transactionproductMigration(tx)
        orderMigration(tx)

        if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                panic(err)</span>
        }
}

func orderMigration(tx *gorm.DB) <span class="cov0" title="0">{
        err := tx.Migrator().CreateTable(&amp;model.Order{})
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

func productMigration(tx *gorm.DB) <span class="cov0" title="0">{
        err := tx.Migrator().CreateTable(&amp;model.Product{})
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

func stockMigration(tx *gorm.DB) <span class="cov0" title="0">{
        err := tx.Migrator().CreateTable(&amp;model.Stock{})
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

func transactionMigration(tx *gorm.DB) <span class="cov0" title="0">{
        err := tx.Migrator().CreateTable(&amp;model.Transaction{})
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}
func transactionproductMigration(tx *gorm.DB) <span class="cov0" title="0">{
        err := tx.Migrator().CreateTable(&amp;model.TransactionProduct{})
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "fmt"
        "github.com/kizmey/order_management_system/config"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

type postgresDatabase struct {
        *gorm.DB
}

func NewPostgresDatabase(conf *config.Database) Database <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s search_path=%s ",
                conf.Host,
                conf.Port,
                conf.User,
                conf.Password,
                conf.DBName,
                conf.SSLMode,
                conf.Schema,
        )
        conn, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">fmt.Println("Connect Database : ", conn.Name())

        return &amp;postgresDatabase{conn}</span>
}

func (p *postgresDatabase) Connect() *gorm.DB <span class="cov0" title="0">{
        return p.DB
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// main.go
package main

import (
        "github.com/kizmey/order_management_system/config"
        "github.com/kizmey/order_management_system/database"
        logger "github.com/kizmey/order_management_system/observability/logs"
        customTracer "github.com/kizmey/order_management_system/observability/tracer"
        "github.com/kizmey/order_management_system/pkg"
        serverPkg "github.com/kizmey/order_management_system/server/httpEchoServer"
        "github.com/sirupsen/logrus"
        "os"
)

func main() <span class="cov0" title="0">{
        // Initialize Logger
        logger.InitLogger()
        defer func(LogFile *os.File) </span><span class="cov0" title="0">{
                err := LogFile.Close()
                if err != nil </span>{<span class="cov0" title="0">
                }</span>
        }(logger.LogFile)

        <span class="cov0" title="0">fields := logrus.Fields{"module": "main", "function": "main"}
        logger.LogInfo("Service started", fields)

        conf := config.GettingConfig()
        db := database.NewPostgresDatabase(conf.Database)

        usecases := pkg.InitUsecase(db)
        err := customTracer.InitOpenTelemetry()
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to initialize OpenTelemetry"+err.Error(), fields)
        }</span>

        <span class="cov0" title="0">server := serverPkg.NewEchoServer(conf, usecases)
        server.Start()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package logger

import (
        "github.com/sirupsen/logrus"
        "os"
)

var (
        LogFile *os.File
        Logger  *logrus.Logger
)

func InitLogger() <span class="cov0" title="0">{
        var err error
        LogFile, err = os.OpenFile("./observability/logs/temp/logs.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to open log file: %v", err)
        }</span>

        <span class="cov0" title="0">Logger = logrus.New()
        Logger.SetOutput(LogFile)
        Logger.SetFormatter(&amp;logrus.JSONFormatter{})
        Logger.SetLevel(logrus.InfoLevel)</span>
}

func LogInfo(message string, fields logrus.Fields) <span class="cov0" title="0">{
        Logger.WithFields(fields).Info(message)
}</span>

func LogWarn(message string, fields logrus.Fields) <span class="cov0" title="0">{
        Logger.WithFields(fields).Warn(message)
}</span>

func LogError(message string, fields logrus.Fields) <span class="cov0" title="0">{
        Logger.WithFields(fields).Error(message)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package observability

import (
        "github.com/prometheus/client_golang/prometheus"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/disk"
        "github.com/shirou/gopsutil/mem"
        "time"
)

var (
        CPUPercentage = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "cpu_percentage",
                        Help: "Current CPU usage percentage",
                },
        )

        MemoryUsed = prometheus.NewGauge(
                prometheus.GaugeOpts{
                        Name: "memory_used",
                        Help: "Current memory usage in bytes",
                },
        )

        DiskUsage = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "disk_usage",
                        Help: "Current disk usage in bytes",
                },
                []string{"disk"},
        )
)

func InitMetrics() <span class="cov0" title="0">{
        prometheus.MustRegister(CPUPercentage)
        prometheus.MustRegister(MemoryUsed)
        prometheus.MustRegister(DiskUsage)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        updateMetrics()
                        time.Sleep(1 * time.Second)
                }</span>
        }()
}

func updateMetrics() <span class="cov0" title="0">{
        // CPU Usage
        cpuPercent, err := cpu.Percent(time.Second, true)
        if err == nil &amp;&amp; len(cpuPercent) &gt; 0 </span><span class="cov0" title="0">{
                CPUPercentage.Set(cpuPercent[0])
        }</span>

        // Memory Usage
        <span class="cov0" title="0">memInfo, err := mem.VirtualMemory()
        if err == nil </span><span class="cov0" title="0">{
                MemoryUsed.Set(float64(memInfo.Used))
        }</span>

        // Disk Usage
        <span class="cov0" title="0">partitions, err := disk.Partitions(false)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, partition := range partitions </span><span class="cov0" title="0">{
                usageStat, err := disk.Usage(partition.Mountpoint)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">DiskUsage.WithLabelValues(partition.Device).Set(float64(usageStat.Used))</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package customTracer

import (
        "context"
        "encoding/json"
        "github.com/go-logr/stdr"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        "go.opentelemetry.io/otel/semconv/v1.21.0" // Import semconv package
        "go.opentelemetry.io/otel/trace"
        "log"
        "os"
)

func InitOpenTelemetry() error <span class="cov0" title="0">{
        // Set up loggerx
        loggerx := stdr.New(log.New(os.Stdout, "", log.LstdFlags|log.Lshortfile))
        otel.SetLogger(loggerx)

        // Set up Propagators
        propagator := propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        )
        otel.SetTextMapPropagator(propagator)

        // Set up trace provider
        ctx := context.Background()
        traceExporter, err := otlptrace.New(ctx, otlptracehttp.NewClient(
                otlptracehttp.WithInsecure(),
                otlptracehttp.WithEndpoint("localhost:4318"),
        ))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">res := resource.NewWithAttributes(
                semconv.SchemaURL,
                semconv.ServiceNameKey.String("order_management_system"),
        )

        tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(traceExporter),
                sdktrace.WithResource(res),
        )
        otel.SetTracerProvider(tp)
        return nil</span>
}

func SetSubAttributesWithJson(obj any, sp trace.Span) <span class="cov8" title="1">{
        objJson, err := json.Marshal(obj)
        if err != nil </span>{<span class="cov0" title="0">
        }</span>
        <span class="cov8" title="1">sp.SetAttributes(
                attribute.String("result", string(objJson)),
        )</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package order

import (
        logger "github.com/kizmey/order_management_system/observability/logs"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/kizmey/order_management_system/pkg/interface/modelReq"
        "github.com/kizmey/order_management_system/pkg/interface/modelRes"
        _orderService "github.com/kizmey/order_management_system/pkg/service/order"
        "github.com/kizmey/order_management_system/server/httpEchoServer/custom"
        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
        "net/http"
)

type orderControllerImpl struct {
        orderService _orderService.OrderService
}

func NewOrderControllerImpl(orderService _orderService.OrderService) OrderController <span class="cov0" title="0">{
        return &amp;orderControllerImpl{orderService}
}</span>

func (c *orderControllerImpl) Create(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "orderCreateController")
        defer sp.End()

        newOrderReq := new(modelReq.Order)
        validatingContext := custom.NewCustomEchoRequest(pctx)
        if err := validatingContext.BindAndValidate(newOrderReq); err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to validate order request", logrus.Fields{"error": err.Error()})
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateOrderRequest)
        }</span>

        <span class="cov0" title="0">order := c.orderReqToEntity(newOrderReq)
        newOrderRes, err := c.orderService.Create(ctx, order)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to create order", logrus.Fields{"error": err.Error()})
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToCreateOrder)
        }</span>

        <span class="cov0" title="0">logger.LogInfo("Order created successfully", logrus.Fields{"order_id": newOrderRes.OrderID})

        orderRes := c.orderEntityToModelRes(newOrderRes)
        return pctx.JSON(http.StatusCreated, orderRes)</span>
}

func (c *orderControllerImpl) FindAll(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "orderFindAllController")
        defer sp.End()

        orderListingResult, err := c.orderService.FindAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to retrieve order list", logrus.Fields{"error": err.Error()})
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToRetrieveOrders)
        }</span>

        <span class="cov0" title="0">logger.LogInfo("Retrieved order list successfully", nil)

        allOrder := make([]modelRes.Order, 0)
        for _, order := range *orderListingResult </span><span class="cov0" title="0">{
                allOrder = append(allOrder, *c.orderEntityToModelRes(&amp;order))
        }</span>

        <span class="cov0" title="0">return pctx.JSON(http.StatusOK, allOrder)</span>
}

func (c *orderControllerImpl) FindByID(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "orderFindByIdController")
        defer sp.End()

        id := pctx.Param("id")

        newOrderRes, err := c.orderService.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to find order by ID", logrus.Fields{"error": err.Error(), "order_id": id})
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrOrderNotFound)
        }</span>

        <span class="cov0" title="0">logger.LogInfo("Found order by ID", logrus.Fields{"order_id": newOrderRes.OrderID})

        orderRes := c.orderEntityToModelRes(newOrderRes)
        return pctx.JSON(http.StatusOK, orderRes)</span>
}

func (c *orderControllerImpl) Update(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "orderUpdateController")
        defer sp.End()

        id := pctx.Param("id")

        orderReq := new(modelReq.Order)
        validatingContext := custom.NewCustomEchoRequest(pctx)
        if err := validatingContext.BindAndValidate(orderReq); err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to validate order update request", logrus.Fields{"error": err.Error()})
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateOrderRequest)
        }</span>

        <span class="cov0" title="0">order := c.orderReqToEntity(orderReq)
        newOrderRes, err := c.orderService.Update(ctx, id, order)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to update order", logrus.Fields{"error": err.Error(), "order_id": id})
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToUpdateOrder)
        }</span>
        <span class="cov0" title="0">logger.LogInfo("Order updated successfully", logrus.Fields{"order_id": newOrderRes.OrderID})

        orderRes := c.orderEntityToModelRes(newOrderRes)
        return pctx.JSON(http.StatusOK, orderRes)</span>
}

func (c *orderControllerImpl) Delete(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "orderDeleteController")
        defer sp.End()

        id := pctx.Param("id")

        newOrderEntity, err := c.orderService.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to delete order", logrus.Fields{"error": err.Error(), "order_id": id})
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToDeleteOrder)
        }</span>

        <span class="cov0" title="0">logger.LogInfo("Order deleted successfully", logrus.Fields{"order_id": newOrderEntity.OrderID})

        orderRes := c.orderEntityToModelRes(newOrderEntity)
        return pctx.JSON(http.StatusOK, orderRes)</span>
}

func (c *orderControllerImpl) ChangeStatusNext(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "orderChangeStatusNextController")
        defer sp.End()

        orderId := pctx.Param("id")
        //if orderId == "" {
        //        err := custom.ErrOrderNotFound
        //        logger.LogWarn("Order id not found", logrus.Fields{"error": err.Error()})
        //        return custom.Error(pctx, http.StatusBadRequest, err)
        //}

        newOrderRes, err := c.orderService.ChangeStatusNext(ctx, orderId)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to change order status", logrus.Fields{"error": err.Error(), "order_id": orderId})
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToChangeOrderStatus)
        }</span>

        <span class="cov0" title="0">logger.LogInfo("Order status changed successfully", logrus.Fields{"order_id": newOrderRes.OrderID, "new_status": newOrderRes.Status})
        orderRes := c.orderEntityToModelRes(newOrderRes)
        return pctx.JSON(http.StatusOK, orderRes)</span>
}

func (c *orderControllerImpl) ChageStatusDone(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "orderChageStatusDoneController")
        defer sp.End()

        id := pctx.Param("id")

        logger.LogInfo("Changing order status to done", logrus.Fields{"order_id": id})
        newOrderRes, err := c.orderService.ChageStatusDone(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                logger.LogError("Failed to change order status to done", logrus.Fields{"error": err.Error(), "order_id": id})
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToChangeOrderStatus)
        }</span>

        <span class="cov0" title="0">logger.LogInfo("Order status changed to done successfully", logrus.Fields{"order_id": newOrderRes.OrderID})
        orderRes := c.orderEntityToModelRes(newOrderRes)
        return pctx.JSON(http.StatusOK, orderRes)</span>
}

func (c *orderControllerImpl) orderReqToEntity(orderReq *modelReq.Order) *entities.Order <span class="cov0" title="0">{
        return &amp;entities.Order{
                TransactionID: orderReq.TransactionID,
                Status:        orderReq.Status,
        }
}</span>

func (c *orderControllerImpl) orderEntityToModelRes(order *entities.Order) *modelRes.Order <span class="cov0" title="0">{
        return &amp;modelRes.Order{
                OrderID:       order.OrderID,
                TransactionID: order.TransactionID,
                Status:        order.Status,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package product

import (
        "encoding/json"
        customTracer "github.com/kizmey/order_management_system/observability/tracer"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/kizmey/order_management_system/pkg/interface/modelReq"
        "github.com/kizmey/order_management_system/pkg/interface/modelRes"
        _productService "github.com/kizmey/order_management_system/pkg/service/product"
        "github.com/kizmey/order_management_system/server/httpEchoServer/custom"
        "github.com/labstack/echo/v4"
        "go.opentelemetry.io/otel/attribute"
        "net/http"
)

type productController struct {
        productService _productService.ProductService
}

func NewProductControllerImpl(productService _productService.ProductService) ProductController <span class="cov0" title="0">{
        return &amp;productController{
                productService: productService,
        }
}</span>

func (c *productController) Create(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "productCreateController")
        defer sp.End()

        productReq := new(modelReq.Product)

        validatingContext := custom.NewCustomEchoRequest(pctx)
        if err := validatingContext.BindAndValidate(productReq); err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateProductRequest)
        }</span>
        <span class="cov0" title="0">product := c.productReqToEntity(productReq)
        product, err := c.productService.Create(ctx, product)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToCreateProduct)
        }</span>

        <span class="cov0" title="0">customTracer.SetSubAttributesWithJson(product, sp)

        productRes := c.productReqToEntity(productReq)
        return pctx.JSON(http.StatusCreated, productRes)</span>
}

func (c *productController) FindAll(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "productFindAllController")
        defer sp.End()

        productListingResult, err := c.productService.FindAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToRetrieveProducts)
        }</span>

        <span class="cov0" title="0">productJSON, err := json.Marshal(productListingResult)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToRetrieveProducts)
        }</span>
        <span class="cov0" title="0">sp.SetAttributes(
                attribute.String("product.listing", string(productJSON)),
        )

        productsRes := make([]modelRes.Product, 0)
        for _, product := range *productListingResult </span><span class="cov0" title="0">{
                productsRes = append(productsRes, *c.productEntityToRes(&amp;product))
        }</span>

        <span class="cov0" title="0">return pctx.JSON(http.StatusOK, productsRes)</span>
}

func (c *productController) FindByID(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "productFindByIdController")
        defer sp.End()

        id := pctx.Param("id")

        product, err := c.productService.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrProductNotFound)
        }</span>

        <span class="cov0" title="0">productRes := c.productEntityToRes(product)
        return pctx.JSON(http.StatusOK, productRes)</span>
}

func (c *productController) Update(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "productUpdateController")
        defer sp.End()

        id := pctx.Param("id")

        productReq := new(modelReq.Product)

        validatingContext := custom.NewCustomEchoRequest(pctx)
        if err := validatingContext.BindAndValidate(productReq); err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateProductRequest)
        }</span>

        <span class="cov0" title="0">product := c.productReqToEntity(productReq)
        product, err := c.productService.Update(ctx, id, product)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToUpdateProduct)
        }</span>

        <span class="cov0" title="0">productRes := c.productEntityToRes(product)
        return pctx.JSON(http.StatusOK, productRes)</span>
}

func (c *productController) Delete(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "productDeleteController")
        defer sp.End()

        id := pctx.Param("id")

        product, err := c.productService.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToDeleteProduct)
        }</span>

        <span class="cov0" title="0">productRes := c.productEntityToRes(product)
        return pctx.JSON(http.StatusOK, productRes)</span>
}

func (c *productController) productReqToEntity(product *modelReq.Product) *entities.Product <span class="cov0" title="0">{
        return &amp;entities.Product{
                ProductName:  product.ProductName,
                ProductPrice: product.ProductPrice,
        }

}</span>

func (c *productController) productEntityToRes(product *entities.Product) *modelRes.Product <span class="cov0" title="0">{
        return &amp;modelRes.Product{
                ProductID:    product.ProductID,
                ProductName:  product.ProductName,
                ProductPrice: product.ProductPrice,
        }

}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package stock

import (
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/kizmey/order_management_system/pkg/interface/modelReq"
        "github.com/kizmey/order_management_system/pkg/interface/modelRes"
        _StockService "github.com/kizmey/order_management_system/pkg/service/stock"
        "github.com/kizmey/order_management_system/server/httpEchoServer/custom"
        "github.com/labstack/echo/v4"
        "net/http"
)

type stockControllerImpl struct {
        stockService _StockService.StockService
}

func NewStockControllerImpl(stockController _StockService.StockService) StockController <span class="cov0" title="0">{
        return &amp;stockControllerImpl{stockService: stockController}
}</span>

func (c *stockControllerImpl) Create(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "stockCreateController")
        defer sp.End()

        stockReq := new(modelReq.Stock)

        validatingContext := custom.NewCustomEchoRequest(pctx)
        if err := validatingContext.BindAndValidate(stockReq); err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateStockRequest)
        }</span>

        <span class="cov0" title="0">stockEntity := c.stockReqToEntity(stockReq)
        stock, err := c.stockService.Create(ctx, stockEntity)

        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToCreateStock)
        }</span>
        <span class="cov0" title="0">stockRes := c.stockEntityToRes(stock)
        return pctx.JSON(http.StatusCreated, stockRes)</span>
}

func (c *stockControllerImpl) FindAll(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "stockFindAllController")
        defer sp.End()

        stockListingResult, err := c.stockService.FindAll(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToRetrieveStocks)
        }</span>

        <span class="cov0" title="0">var stockRes []modelRes.Stock
        for _, stock := range *stockListingResult </span><span class="cov0" title="0">{
                stockRes = append(stockRes, *c.stockEntityToRes(&amp;stock))
        }</span>

        <span class="cov0" title="0">return pctx.JSON(http.StatusOK, stockRes)</span>
}

func (c *stockControllerImpl) CheckStockByProductId(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "CheckStockByProductIdController")
        defer sp.End()

        id := pctx.Param("id")

        stock, err := c.stockService.CheckStockByProductId(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrStockNotFound)
        }</span>

        <span class="cov0" title="0">stockRes := c.stockEntityToRes(stock)
        return pctx.JSON(http.StatusOK, stockRes)</span>
}

func (c *stockControllerImpl) Update(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "stockUpdateController")
        defer sp.End()

        id := pctx.Param("id")

        stockReq := new(modelReq.Stock)

        validatingContext := custom.NewCustomEchoRequest(pctx)
        if err := validatingContext.BindAndValidate(stockReq); err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateStockRequest)
        }</span>

        <span class="cov0" title="0">stockEntity := c.stockReqToEntity(stockReq)
        stock, err := c.stockService.Update(ctx, id, stockEntity)

        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToUpdateStock)
        }</span>

        <span class="cov0" title="0">stockRes := c.stockEntityToRes(stock)
        return pctx.JSON(http.StatusCreated, stockRes)</span>
}

func (c *stockControllerImpl) Delete(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "stockDeleteController")
        defer sp.End()
        id := pctx.Param("id")

        stock, err := c.stockService.Delete(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToDeleteStock)
        }</span>

        <span class="cov0" title="0">stockRes := c.stockEntityToRes(stock)
        return pctx.JSON(http.StatusOK, stockRes)</span>
}

func (c *stockControllerImpl) stockReqToEntity(stockReq *modelReq.Stock) *entities.Stock <span class="cov0" title="0">{
        return &amp;entities.Stock{
                ProductID: stockReq.ProductID,
                Quantity:  stockReq.Quantity,
        }
}</span>

func (c *stockControllerImpl) stockEntityToRes(stock *entities.Stock) *modelRes.Stock <span class="cov0" title="0">{
        return &amp;modelRes.Stock{
                StockID:   stock.StockID,
                ProductID: stock.ProductID,
                Quantity:  stock.Quantity,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package transaction

import (
        _interface "github.com/kizmey/order_management_system/pkg/interface/aggregation"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/kizmey/order_management_system/pkg/interface/modelReq"
        "github.com/kizmey/order_management_system/pkg/interface/modelRes"
        _transactionService "github.com/kizmey/order_management_system/pkg/service/transaction"
        "github.com/kizmey/order_management_system/server/httpEchoServer/custom"
        "github.com/labstack/echo/v4"
        "net/http"
)

type transactionControllerImpl struct {
        transaction _transactionService.TransactionService
}

func NewTransactionControllerImpl(transaction _transactionService.TransactionService) TransactionController <span class="cov0" title="0">{
        return &amp;transactionControllerImpl{
                transaction: transaction,
        }
}</span>

func (c *transactionControllerImpl) Create(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "transactionCreateController")
        defer sp.End()

        transactionReq := new(modelReq.Transaction)

        validatingContext := custom.NewCustomEchoRequest(pctx)
        if err := validatingContext.BindAndValidate(transactionReq); err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateTransactionRequest)
        }</span>

        <span class="cov0" title="0">if !isProductIDsUnique(transactionReq.Product) </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateTransactionRequest)
        }</span>

        <span class="cov0" title="0">transactionEntity := c.transactionReqToAggregation(transactionReq)

        transaction, err := c.transaction.Create(ctx, transactionEntity)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToCreateTransaction)
        }</span>

        <span class="cov0" title="0">transactionRes := c.transactionAndproductEntityToRes(transaction)
        return pctx.JSON(http.StatusCreated, transactionRes)</span>
}

func (c *transactionControllerImpl) FindAll(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "transactionFindAllController")
        defer sp.End()

        transactions, err := c.transaction.FindAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToRetrieveTransactions)
        }</span>

        <span class="cov0" title="0">allTransaction := make([]modelRes.Transaction, 0)
        for _, transactionEntity := range *transactions </span><span class="cov0" title="0">{
                allTransaction = append(allTransaction, *c.transactionEntityToRes(&amp;transactionEntity))
        }</span>

        <span class="cov0" title="0">return pctx.JSON(http.StatusOK, allTransaction)</span>
}

func (c *transactionControllerImpl) FindByID(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "transactionFindByIdController")
        defer sp.End()

        id := pctx.Param("id")

        transaction, err := c.transaction.FindByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrTransactionNotFound)
        }</span>

        <span class="cov0" title="0">transactionRes := c.transactionEntityToRes(transaction)
        return pctx.JSON(http.StatusOK, transactionRes)</span>
}

func (c *transactionControllerImpl) Update(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "transactionUpdateController")
        defer sp.End()

        id := pctx.Param("id")
        transactionReq := new(modelReq.Transaction)

        validatingContext := custom.NewCustomEchoRequest(pctx)
        if err := validatingContext.BindAndValidate(transactionReq); err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateTransactionRequest)
        }</span>

        <span class="cov0" title="0">if !isProductIDsUnique(transactionReq.Product) </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusBadRequest, custom.ErrFailedToValidateTransactionRequest)
        }</span>

        <span class="cov0" title="0">transaction := c.transactionReqToAggregation(transactionReq)
        transaction, err := c.transaction.Update(ctx, id, transaction)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToUpdateTransaction)
        }</span>

        <span class="cov0" title="0">transactionRes := c.transactionAndproductEntityToRes(transaction)
        return pctx.JSON(http.StatusOK, transactionRes)</span>
}

func (c *transactionControllerImpl) Delete(pctx echo.Context) error <span class="cov0" title="0">{
        ctx, sp := tracer.Start(pctx.Request().Context(), "transactionDeleteController")
        defer sp.End()

        id := pctx.Param("id")

        transaction, err := c.transaction.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return custom.Error(pctx, http.StatusInternalServerError, custom.ErrFailedToDeleteTransaction)
        }</span>

        <span class="cov0" title="0">transactionRes := c.transactionEntityToRes(transaction)
        return pctx.JSON(http.StatusOK, transactionRes)</span>
}

func isProductIDsUnique(products []modelReq.ProductItem) bool <span class="cov0" title="0">{
        seen := make(map[string]struct{})
        for _, item := range products </span><span class="cov0" title="0">{
                if _, found := seen[item.ProductID]; found </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">seen[item.ProductID] = struct{}{}</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (c *transactionControllerImpl) transactionReqToAggregation(transactionReq *modelReq.Transaction) *_interface.TransactionEcommerce <span class="cov0" title="0">{
        mapProduct := make(map[string]uint)
        for _, item := range transactionReq.Product </span><span class="cov0" title="0">{
                mapProduct[item.ProductID] = item.Quantity
        }</span>

        <span class="cov0" title="0">transaction := entities.Transaction{
                IsDomestic: transactionReq.IsDomestic,
        }

        return _interface.NewTransactionEcommerce(&amp;transaction, nil, mapProduct)</span>
}

func (c *transactionControllerImpl) transactionAndproductEntityToRes(transactionEntity *_interface.TransactionEcommerce) *modelRes.Transaction <span class="cov0" title="0">{
        products := make([]modelRes.Product, 0)

        for _, product := range transactionEntity.Product </span><span class="cov0" title="0">{
                products = append(products, modelRes.Product{
                        ProductID:   product.ProductID,
                        ProductName: product.ProductName,
                        Quantity:    transactionEntity.AddessProduct[product.ProductID],
                })
        }</span>

        <span class="cov0" title="0">return &amp;modelRes.Transaction{
                TransactionID: transactionEntity.Tranasaction.TransactionID,
                IsDomestic:    transactionEntity.Tranasaction.IsDomestic,
                SumPrice:      transactionEntity.Tranasaction.SumPrice,
                Products:      products,
        }</span>
}

func (c *transactionControllerImpl) transactionEntityToRes(transactionEntity *entities.Transaction) *modelRes.Transaction <span class="cov0" title="0">{
        return &amp;modelRes.Transaction{
                TransactionID: transactionEntity.TransactionID,
                IsDomestic:    transactionEntity.IsDomestic,
                SumPrice:      transactionEntity.SumPrice,
        }

}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package aggregation

import "github.com/kizmey/order_management_system/pkg/interface/entities"

type Ecommerce struct {
        Order    *entities.Order
        Product  []entities.Product
        Quantity []uint
}

func NewEcommerce(order *entities.Order, products []entities.Product, quantity []uint) *Ecommerce <span class="cov8" title="1">{
        return &amp;Ecommerce{
                Order:    order,
                Product:  products,
                Quantity: quantity,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package aggregation

import (
        "github.com/kizmey/order_management_system/pkg/interface/entities"
)

type TransactionEcommerce struct {
        Tranasaction  *entities.Transaction
        Product       []entities.Product
        AddessProduct map[string]uint
}

const (
        // Domestic price
        Domestic = uint(100)
        // NotDomestic price
        NotDomestic = uint(500)
)

func (m *TransactionEcommerce) CalculatePrice() uint <span class="cov8" title="1">{
        m.Tranasaction.SumPrice = 0
        for _, product := range m.Product </span><span class="cov8" title="1">{
                m.Tranasaction.SumPrice += product.ProductPrice * m.AddessProduct[product.ProductID]
        }</span>

        <span class="cov8" title="1">if m.Tranasaction.IsDomestic </span><span class="cov8" title="1">{
                m.Tranasaction.SumPrice += Domestic
        }</span> else<span class="cov8" title="1"> {
                m.Tranasaction.SumPrice += NotDomestic
        }</span>

        <span class="cov8" title="1">return m.Tranasaction.SumPrice</span>
}

func NewTransactionEcommerce(tranasaction *entities.Transaction, product []entities.Product, addessProduct map[string]uint) *TransactionEcommerce <span class="cov8" title="1">{
        return &amp;TransactionEcommerce{
                Tranasaction:  tranasaction,
                Product:       product,
                AddessProduct: addessProduct,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package entities

import (
        "errors"
)

type Order struct {
        OrderID       string
        TransactionID string
        Status        string
}

var (
        OrderStatus = []string{"New", "Paid", "Processing", "Done"}
)

func (m *Order) NextStatus() error <span class="cov8" title="1">{
        for i := 0; i &lt; len(OrderStatus); i++ </span><span class="cov8" title="1">{

                if m.Status == OrderStatus[len(OrderStatus)-1] </span><span class="cov8" title="1">{
                        return errors.New("order is already done")
                }</span>

                <span class="cov8" title="1">if OrderStatus[i] == m.Status </span><span class="cov8" title="1">{
                        m.Status = OrderStatus[i+1]
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return errors.New("invalid order status")</span>
}

func (m *Order) NextPaidToDone() error <span class="cov8" title="1">{

        if m.Status == "Paid" </span><span class="cov8" title="1">{
                m.Status = "Done"
                return nil
        }</span>

        <span class="cov8" title="1">return errors.New("invalid order status")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package model

import (
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "time"
)

type Order struct {
        ID            string      `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        TransactionID string      `gorm:"not null; unique;" `
        Transaction   Transaction `gorm:"foreignKey:TransactionID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
        Status        string      `gorm:"type:varchar(20);not null;default:New"`
        CreatedAt     time.Time   `gorm:"not null;autoCreateTime;"`
        UpdatedAt     time.Time   `gorm:"not null;autoUpdateTime;"`
}

func (m *Order) ToOrderEntity() *entities.Order <span class="cov0" title="0">{
        return &amp;entities.Order{
                OrderID:       m.ID,
                TransactionID: m.TransactionID,
                Status:        m.Status,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package model

import (
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "time"
)

type Product struct {
        ID        string    `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        Name      string    `gorm:"type:varchar(128);not null;" `
        Price     uint      `gorm:"not null;"`
        CreatedAt time.Time `gorm:"not null;autoCreateTime;" `
        UpdatedAt time.Time `gorm:"not null;autoUpdateTime;" `
}

func (m *Product) ToProductEntity() *entities.Product <span class="cov0" title="0">{
        return &amp;entities.Product{
                ProductID:    m.ID,
                ProductName:  m.Name,
                ProductPrice: m.Price,
        }
}</span>
func ConvertProductModelsToEntities(products *[]Product) *[]entities.Product <span class="cov0" title="0">{
        entityProducts := new([]entities.Product)

        for _, product := range *products </span><span class="cov0" title="0">{
                *entityProducts = append(*entityProducts, *product.ToProductEntity())
        }</span>

        <span class="cov0" title="0">return entityProducts</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package model

import (
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "time"
)

type Stock struct {
        ID        string    `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        ProductID string    `gorm:"unique;not null;" `
        Product   Product   `gorm:"foreignKey:ProductID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
        Quantity  uint      `gorm:"not null;" `
        CreatedAt time.Time `gorm:"not null;autoCreateTime;" `
        UpdatedAt time.Time `gorm:"not null;autoUpdateTime;" `
}

func (m *Stock) ToStockEntity() *entities.Stock <span class="cov0" title="0">{
        return &amp;entities.Stock{
                StockID:   m.ID,
                ProductID: m.ProductID,
                Quantity:  m.Quantity,
        }
}</span>

func ConvertStockModelsToEntities(stocks *[]Stock) *[]entities.Stock <span class="cov0" title="0">{
        entityStocks := new([]entities.Stock)

        for _, stock := range *stocks </span><span class="cov0" title="0">{
                *entityStocks = append(*entityStocks, *stock.ToStockEntity())
        }</span>

        <span class="cov0" title="0">return entityStocks</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package model

import (
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "time"
)

type Transaction struct {
        ID         string    `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        IsDomestic bool      `gorm:"not null; default:false;"`
        SumPrice   uint      `gorm:"not null;" `
        ProductID  string    `gorm:"not null;" `
        Products   []Product `gorm:"many2many:transaction_products;"`
        CreatedAt  time.Time `gorm:"not null;autoCreateTime;"`
        UpdatedAt  time.Time `gorm:"not null;autoUpdateTime;"`
}

type TransactionProduct struct {
        ID            string      `gorm:"type:uuid;default:uuid_generate_v4();primaryKey"`
        TransactionID string      `gorm:"not null;" `
        Transaction   Transaction `gorm:"foreignKey:TransactionID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
        ProductID     string      `gorm:"not null;" `
        Product       Product     `gorm:"foreignKey:ProductID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
        Quantity      uint        `gorm:" not null; default:1" `
}

func (m *Transaction) ToTransactionEntity() *entities.Transaction <span class="cov0" title="0">{
        return &amp;entities.Transaction{
                TransactionID: m.ID,
                SumPrice:      m.SumPrice,
                IsDomestic:    m.IsDomestic,
        }
}</span>

func ConvertModelsTransactionToEntities(transactions *[]Transaction) *[]entities.Transaction <span class="cov0" title="0">{
        entityTransaction := new([]entities.Transaction)

        for _, transaction := range *transactions </span><span class="cov0" title="0">{

                *entityTransaction = append(*entityTransaction, *transaction.ToTransactionEntity())
        }</span>

        <span class="cov0" title="0">return entityTransaction</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package order

import (
        "context"
        customTracer "github.com/kizmey/order_management_system/observability/tracer"

        "errors"
        "fmt"
        "github.com/kizmey/order_management_system/database"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/kizmey/order_management_system/pkg/interface/model"
)

type orderRepositoryImpl struct {
        db database.Database
}

func NewOrderRepositoryImpl(db database.Database) OrderRepository <span class="cov0" title="0">{
        return &amp;orderRepositoryImpl{db: db}
}</span>

func (r *orderRepositoryImpl) Create(ctx context.Context, order *entities.Order) (*entities.Order, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "orderCreateRepository")
        defer sp.End()

        modelOrder := ToOrderModel(order)
        if err := r.db.Connect().Create(&amp;modelOrder).Preload("Transaction").Where("id = ?", modelOrder.ID).First(&amp;modelOrder).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("create order error "))
        }</span>

        <span class="cov0" title="0">customTracer.SetSubAttributesWithJson(modelOrder.ToOrderEntity(), sp)

        return modelOrder.ToOrderEntity(), nil</span>
}

func (r *orderRepositoryImpl) FindAll(ctx context.Context) (*[]entities.Order, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "orderFindAllRepository")
        defer sp.End()

        orders := new([]model.Order)

        if err := r.db.Connect().Preload("Transaction").Find(orders).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("find all order error "))
        }</span>
        <span class="cov0" title="0">allOrder := ConvertOrderModelsToEntities(orders)

        return allOrder, nil</span>
}
func (r *orderRepositoryImpl) FindByID(ctx context.Context, id string) (*entities.Order, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "orderFindByIdRepository")
        defer sp.End()

        order := new(model.Order)
        if err := r.db.Connect().Preload("Transaction").Where("id = ?", id).First(&amp;order).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("find by id order error "))
        }</span>
        <span class="cov0" title="0">return order.ToOrderEntity(), nil</span>
}

func (r *orderRepositoryImpl) Update(ctx context.Context, id string, order *entities.Order) (*entities.Order, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "orderUpdateRepository")
        defer sp.End()

        modelOrder := ToOrderModel(order)
        if err := r.db.Connect().Model(&amp;modelOrder).Where("id = ?", id).Updates(&amp;modelOrder).Scan(modelOrder).Where("id = ?", id).First(&amp;modelOrder).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("update order error "))
        }</span>

        <span class="cov0" title="0">return modelOrder.ToOrderEntity(), nil</span>
}

func (r *orderRepositoryImpl) UpdateStatus(ctx context.Context, id string, order *entities.Order) (*entities.Order, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "orderUpdateRepository")
        defer sp.End()

        orderModel := ToOrderModel(order)

        if err := r.db.Connect().Model(&amp;orderModel).Where("id = ?", id).Updates(&amp;orderModel).Scan(orderModel).Preload("Transaction").Where("id = ?", id).First(&amp;orderModel).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("update order error "))
        }</span>
        <span class="cov0" title="0">return orderModel.ToOrderEntity(), nil</span>
}

func (r *orderRepositoryImpl) Delete(ctx context.Context, id string) (*entities.Order, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "orderDeleteRepository")
        defer sp.End()

        order := new(model.Order)
        if err := r.db.Connect().Where("id = ?", id).First(&amp;order).Delete(&amp;order).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to delete order"))
        }</span>

        <span class="cov0" title="0">return order.ToOrderEntity(), nil</span>
}
func ConvertOrderModelsToEntities(orders *[]model.Order) *[]entities.Order <span class="cov0" title="0">{
        entityOrders := new([]entities.Order)

        for _, order := range *orders </span><span class="cov0" title="0">{
                *entityOrders = append(*entityOrders, *order.ToOrderEntity())
        }</span>

        <span class="cov0" title="0">return entityOrders</span>
}
func ToOrderModel(e *entities.Order) *model.Order <span class="cov0" title="0">{
        //fmt.Println("e: ", e.IsDomestic)
        return &amp;model.Order{
                TransactionID: e.TransactionID,
                Status:        e.Status,
        }
}</span>

//func ToOrderModelRes(e *entities.Order) *modelRes.Order {
//        return &amp;modelRes.Order{
//                OrderID:       e.OrderID,
//                TransactionID: e.TransactionID,
//                //ProductID:     e.ProductID,
//                Status: e.Status,
//        }
//}
</pre>
		
		<pre class="file" id="file19" style="display: none">package order

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/stretchr/testify/mock"
)

type NewOrderRepositoryMock struct {
        mock.Mock
}

func (m *NewOrderRepositoryMock) checkOrderRepositoryMock() OrderRepository <span class="cov0" title="0">{
        return m
}</span>

func (m *NewOrderRepositoryMock) Create(ctx context.Context, order *entities.Order) (*entities.Order, error) <span class="cov8" title="1">{
        args := m.Called(ctx, order)
        return args.Get(0).(*entities.Order), args.Error(1)
}</span>

func (m *NewOrderRepositoryMock) FindAll(ctx context.Context) (*[]entities.Order, error) <span class="cov8" title="1">{
        args := m.Called(ctx)
        return args.Get(0).(*[]entities.Order), args.Error(1)
}</span>

func (m *NewOrderRepositoryMock) FindByID(ctx context.Context, id string) (*entities.Order, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        return args.Get(0).(*entities.Order), args.Error(1)
}</span>

func (m *NewOrderRepositoryMock) Update(ctx context.Context, id string, order *entities.Order) (*entities.Order, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id, order)
        return args.Get(0).(*entities.Order), args.Error(1)
}</span>

func (m *NewOrderRepositoryMock) UpdateStatus(ctx context.Context, id string, order *entities.Order) (*entities.Order, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id, order)
        return args.Get(0).(*entities.Order), args.Error(1)
}</span>

func (m *NewOrderRepositoryMock) Delete(ctx context.Context, id string) (*entities.Order, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        return args.Get(0).(*entities.Order), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package product

import (
        "context"

        "errors"
        "fmt"
        "github.com/kizmey/order_management_system/database"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/kizmey/order_management_system/pkg/interface/model"
)

type productRepositoryImpl struct {
        db database.Database
}

func NewProductRepositoryImpl(db database.Database) ProductRepository <span class="cov0" title="0">{
        return &amp;productRepositoryImpl{db: db}

}</span>

func (r *productRepositoryImpl) Create(ctx context.Context, product *entities.Product) (*entities.Product, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "productCreateRepository")
        defer sp.End()

        modelProduct := ToProductModel(product)
        newProduct := new(model.Product)

        if err := r.db.Connect().Create(modelProduct).Scan(newProduct).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to create product"))
        }</span>
        <span class="cov0" title="0">return newProduct.ToProductEntity(), nil</span>
}

func (r *productRepositoryImpl) FindAll(ctx context.Context) (*[]entities.Product, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "productFindByIdRepository")
        defer sp.End()

        products := new([]model.Product)

        if err := r.db.Connect().Find(products).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to find all products"))
        }</span>
        <span class="cov0" title="0">allProduct := model.ConvertProductModelsToEntities(products)
        return allProduct, nil</span>
}

func (r *productRepositoryImpl) FindByID(ctx context.Context, id string) (*entities.Product, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "productFindByIdRepository")
        defer sp.End()

        product := new(model.Product)

        if err := r.db.Connect().Where("id = ?", id).First(product).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to find product"))
        }</span>
        <span class="cov0" title="0">return product.ToProductEntity(), nil</span>
}

func (r *productRepositoryImpl) Update(ctx context.Context, id string, product *entities.Product) (*entities.Product, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "productFindByIdRepository")
        defer sp.End()

        newProduct := new(model.Product)
        productModel := ToProductModel(product)

        if err := r.db.Connect().Model(&amp;productModel).Where(
                "id = ?", id,
        ).Updates(
                productModel,
        ).Scan(newProduct).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to update product"))
        }</span>
        <span class="cov0" title="0">return newProduct.ToProductEntity(), nil</span>
}

func (r *productRepositoryImpl) Delete(ctx context.Context, id string) (*entities.Product, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "productDeleteRepository")
        defer sp.End()

        product := new(model.Product)
        if err := r.db.Connect().Where("id = ?", id).First(&amp;product).Delete(&amp;product).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to delete product"))
        }</span>

        <span class="cov0" title="0">return product.ToProductEntity(), nil</span>
}

func ToProductModel(e *entities.Product) *model.Product <span class="cov0" title="0">{
        return &amp;model.Product{
                Name:  e.ProductName,
                Price: e.ProductPrice,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package product

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/stretchr/testify/mock"
)

type NewProductRepositoryMock struct {
        mock.Mock
}

func (m *NewProductRepositoryMock) CheckProductRepository() ProductRepository <span class="cov0" title="0">{
        return m
}</span>

func (m *NewProductRepositoryMock) Create(ctx context.Context, product *entities.Product) (*entities.Product, error) <span class="cov8" title="1">{
        args := m.Called(ctx, product)
        if args.Get(0) != nil </span><span class="cov8" title="1">{
                return args.Get(0).(*entities.Product), args.Error(1)
        }</span>
        <span class="cov8" title="1">return nil, args.Error(1)</span>
}

func (m *NewProductRepositoryMock) FindAll(ctx context.Context) (*[]entities.Product, error) <span class="cov8" title="1">{
        args := m.Called(ctx)
        if args.Get(0) != nil </span><span class="cov8" title="1">{
                return args.Get(0).(*[]entities.Product), args.Error(1)
        }</span>
        <span class="cov8" title="1">return nil, args.Error(1)</span>
}

func (m *NewProductRepositoryMock) FindByID(ctx context.Context, id string) (*entities.Product, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        if args.Get(0) != nil </span><span class="cov8" title="1">{
                return args.Get(0).(*entities.Product), args.Error(1)
        }</span>
        <span class="cov8" title="1">return nil, args.Error(1)</span>
}

func (m *NewProductRepositoryMock) Update(ctx context.Context, id string, product *entities.Product) (*entities.Product, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id, product)
        if args.Get(0) != nil </span><span class="cov8" title="1">{
                return args.Get(0).(*entities.Product), args.Error(1)
        }</span>
        <span class="cov8" title="1">return nil, args.Error(1)</span>
}

func (m *NewProductRepositoryMock) Delete(ctx context.Context, id string) (*entities.Product, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        if args.Get(0) != nil </span><span class="cov8" title="1">{
                return args.Get(0).(*entities.Product), args.Error(1)
        }</span>
        <span class="cov8" title="1">return nil, args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package stock

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/modelRes"

        "errors"
        "fmt"
        "github.com/kizmey/order_management_system/database"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/kizmey/order_management_system/pkg/interface/model"
)

type stockRepositoryImpl struct {
        db database.Database
}

func NewStockRepositoryImpl(db database.Database) StockRepository <span class="cov0" title="0">{
        return &amp;stockRepositoryImpl{db: db}
}</span>

func (r *stockRepositoryImpl) Create(ctx context.Context, stock *entities.Stock) (*entities.Stock, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "stockCreateRepository")
        defer sp.End()

        modelStock := ToStockModel(stock)
        newStock := new(model.Stock)

        if err := r.db.Connect().Create(modelStock).Scan(newStock).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to create stock"))
        }</span>

        <span class="cov0" title="0">return newStock.ToStockEntity(), nil</span>
}

func (r *stockRepositoryImpl) FindAll(ctx context.Context) (*[]entities.Stock, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "stockFindAllRepository")
        defer sp.End()

        stocks := new([]model.Stock)
        if err := r.db.Connect().Find(stocks).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to find all stock"))
        }</span>

        <span class="cov0" title="0">allStock := model.ConvertStockModelsToEntities(stocks)
        return allStock, nil</span>
}

func (r *stockRepositoryImpl) CheckStockByProductId(ctx context.Context, productId string) (*entities.Stock, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "stockCheckStockByProductIdRepository")
        defer sp.End()

        stock := new(model.Stock)
        //fmt.Println("productId: ", productId)
        if err := r.db.Connect().Preload("Product").Where("product_id = ?", productId).First(stock).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to find stock"))
        }</span>
        //fmt.Println("stock: ", stock)
        <span class="cov0" title="0">return stock.ToStockEntity(), nil</span>
}

func (r *stockRepositoryImpl) Update(ctx context.Context, stockid string, stock *entities.Stock) (*entities.Stock, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "stockUpdateRepository")
        defer sp.End()

        stocks := new(model.Stock)
        modelStock := ToStockModel(stock)

        if modelStock.Quantity == 0 </span><span class="cov0" title="0">{
                if err := r.db.Connect().Model(&amp;modelStock).
                        Where("id = ?", stockid).
                        Update("quantity", modelStock.Quantity).
                        Scan(stocks).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("failed to update stock"))
                }</span>
        } else<span class="cov0" title="0"> {
                if err := r.db.Connect().Model(&amp;modelStock).
                        Where("id = ? AND ? &gt;= 0", stockid, modelStock.Quantity).
                        Update("quantity", modelStock.Quantity).
                        Scan(stocks).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("failed to update stock"))
                }</span>
        }
        <span class="cov0" title="0">return stocks.ToStockEntity(), nil</span>
}

func (r *stockRepositoryImpl) Delete(ctx context.Context, id string) (*entities.Stock, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "stockDeleteRepository")
        defer sp.End()

        stock := new(model.Stock)
        if err := r.db.Connect().Where("id = ?", id).First(&amp;stock).Delete(&amp;stock).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to delete stock"))
        }</span>

        <span class="cov0" title="0">return stock.ToStockEntity(), nil</span>
}

func ToStockModel(e *entities.Stock) *model.Stock <span class="cov0" title="0">{
        return &amp;model.Stock{
                ProductID: e.ProductID,
                Quantity:  e.Quantity,
        }
}</span>

func ToStockModelRes(e *entities.Stock) *modelRes.Stock <span class="cov0" title="0">{
        return &amp;modelRes.Stock{
                StockID:   e.StockID,
                ProductID: e.ProductID,
                Quantity:  e.Quantity,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package stock

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/stretchr/testify/mock"
)

type NewStockRepositoryMock struct {
        mock.Mock
}

func (m *NewStockRepositoryMock) checkStockRepositoryMock() StockRepository <span class="cov0" title="0">{
        return m
}</span>

func (m *NewStockRepositoryMock) Create(ctx context.Context, stock *entities.Stock) (*entities.Stock, error) <span class="cov8" title="1">{
        args := m.Called(ctx, stock)
        return args.Get(0).(*entities.Stock), args.Error(1)
}</span>

func (m *NewStockRepositoryMock) FindAll(ctx context.Context) (*[]entities.Stock, error) <span class="cov8" title="1">{
        args := m.Called(ctx)
        return args.Get(0).(*[]entities.Stock), args.Error(1)
}</span>

func (m *NewStockRepositoryMock) CheckStockByProductId(ctx context.Context, id string) (*entities.Stock, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        return args.Get(0).(*entities.Stock), args.Error(1)
}</span>

func (m *NewStockRepositoryMock) Update(ctx context.Context, id string, stock *entities.Stock) (*entities.Stock, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id, stock)
        return args.Get(0).(*entities.Stock), args.Error(1)
}</span>

func (m *NewStockRepositoryMock) Delete(ctx context.Context, id string) (*entities.Stock, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        return args.Get(0).(*entities.Stock), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package transaction

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/aggregation"

        "errors"
        "fmt"
        "github.com/kizmey/order_management_system/database"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/kizmey/order_management_system/pkg/interface/model"
)

type transactionRepositoryImpl struct {
        db database.Database
}

func NewTransactionRepositoryImpl(db database.Database) TransactionRepository <span class="cov0" title="0">{
        return &amp;transactionRepositoryImpl{db: db}
}</span>

func (r *transactionRepositoryImpl) Create(ctx context.Context, transaction *aggregation.TransactionEcommerce) (*entities.Transaction, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "transactionCreateRepository")
        defer sp.End()

        transactionModel := ToTransactionModel(transaction)

        if err := r.db.Connect().Create(&amp;transactionModel).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to create transaction"))
        }</span>

        <span class="cov0" title="0">for productID, quantity := range transaction.AddessProduct </span><span class="cov0" title="0">{
                if err := r.db.Connect().Model(&amp;model.TransactionProduct{}).Where("transaction_id = ? AND product_id = ?", transactionModel.ID, productID).Update("quantity", quantity).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("failed to update transaction"))
                }</span>
        }

        <span class="cov0" title="0">return transactionModel.ToTransactionEntity(), nil</span>
}

func (r *transactionRepositoryImpl) FindAll(ctx context.Context) (*[]entities.Transaction, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "transactionFindAllRepository")
        defer sp.End()

        transactions := new([]model.Transaction)

        if err := r.db.Connect().Find(&amp;transactions).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to find transactions"))
        }</span>
        <span class="cov0" title="0">allTransactions := model.ConvertModelsTransactionToEntities(transactions)
        return allTransactions, nil</span>
}

func (r *transactionRepositoryImpl) FindByID(ctx context.Context, id string) (*entities.Transaction, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "transactionFindByIdRepository")
        defer sp.End()

        transaction := new(model.Transaction)
        if err := r.db.Connect().Where("id = ?", id).First(&amp;transaction).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to find transaction"))
        }</span>

        <span class="cov0" title="0">return transaction.ToTransactionEntity(), nil</span>
}

func (r *transactionRepositoryImpl) Update(ctx context.Context, id string, transaction *aggregation.TransactionEcommerce) (*entities.Transaction, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "transactionUpdateRepository")
        defer sp.End()

        transactionModel := ToTransactionModel(transaction)

        transactionModel.ID = id
        fmt.Println(transactionModel)
        if err := r.db.Connect().Model(&amp;model.Transaction{}).Where("id = ?", id).Updates(&amp;transactionModel).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to update transaction"))
        }</span>

        <span class="cov0" title="0">for productID, quantity := range transaction.AddessProduct </span><span class="cov0" title="0">{
                if err := r.db.Connect().Model(&amp;model.TransactionProduct{}).
                        Where("transaction_id = ? AND product_id = ?", id, productID).
                        Update("quantity", quantity).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New(fmt.Sprintf("failed to update transaction"))
                }</span>
        }

        <span class="cov0" title="0">return transactionModel.ToTransactionEntity(), nil</span>
}

func (r *transactionRepositoryImpl) Delete(ctx context.Context, id string) (*entities.Transaction, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "transactionDeleteRepository")
        defer sp.End()

        transaction := new(model.Transaction)
        if err := r.db.Connect().Where("id = ?", id).First(&amp;transaction).Delete(&amp;transaction).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to delete transaction"))
        }</span>

        <span class="cov0" title="0">return transaction.ToTransactionEntity(), nil</span>
}

func (r *transactionRepositoryImpl) FindProductsByTransactionID(ctx context.Context, id string) (*aggregation.Ecommerce, error) <span class="cov0" title="0">{
        ctx, sp := tracer.Start(ctx, "transactionFindProductsByTransactionIDRepository")
        defer sp.End()

        var transactionProducts []model.TransactionProduct
        if err := r.db.Connect().Where("transaction_id = ?", id).Preload("Product").Find(&amp;transactionProducts).Error; err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("failed to find transaction"))
        }</span>

        <span class="cov0" title="0">var products []entities.Product
        var quantity []uint
        for _, transactionProduct := range transactionProducts </span><span class="cov0" title="0">{
                products = append(products, *transactionProduct.Product.ToProductEntity())
                quantity = append(quantity, transactionProduct.Quantity)
        }</span>

        <span class="cov0" title="0">ecommerceProducts := aggregation.NewEcommerce(nil, products, quantity)
        return ecommerceProducts, nil</span>

}

func ToTransactionModel(e *aggregation.TransactionEcommerce) *model.Transaction <span class="cov0" title="0">{
        var productlist []model.Product
        for _, v := range e.Product </span><span class="cov0" title="0">{
                productlist = append(productlist, model.Product{
                        ID:    v.ProductID,
                        Name:  v.ProductName,
                        Price: v.ProductPrice,
                })
        }</span>
        <span class="cov0" title="0">return &amp;model.Transaction{
                SumPrice:   e.Tranasaction.SumPrice,
                IsDomestic: e.Tranasaction.IsDomestic,
                Products:   productlist,
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package transaction

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/aggregation"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        "github.com/stretchr/testify/mock"
)

type NewTransactionRepositoryMock struct {
        mock.Mock
}

func (m *NewTransactionRepositoryMock) transactionRepositoryMock() TransactionRepository <span class="cov0" title="0">{
        return m
}</span>

func (m *NewTransactionRepositoryMock) Create(ctx context.Context, transaction *aggregation.TransactionEcommerce) (*entities.Transaction, error) <span class="cov8" title="1">{
        args := m.Called(ctx, transaction)
        return args.Get(0).(*entities.Transaction), args.Error(1)
}</span>

func (m *NewTransactionRepositoryMock) FindAll(ctx context.Context) (*[]entities.Transaction, error) <span class="cov8" title="1">{
        args := m.Called(ctx)
        return args.Get(0).(*[]entities.Transaction), args.Error(1)
}</span>

func (m *NewTransactionRepositoryMock) FindByID(ctx context.Context, id string) (*entities.Transaction, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        return args.Get(0).(*entities.Transaction), args.Error(1)
}</span>

func (m *NewTransactionRepositoryMock) Update(ctx context.Context, id string, transaction *aggregation.TransactionEcommerce) (*entities.Transaction, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id, transaction)
        return args.Get(0).(*entities.Transaction), args.Error(1)
}</span>

func (m *NewTransactionRepositoryMock) Delete(ctx context.Context, id string) (*entities.Transaction, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        return args.Get(0).(*entities.Transaction), args.Error(1)
}</span>

func (m *NewTransactionRepositoryMock) FindProductsByTransactionID(ctx context.Context, id string) (*aggregation.Ecommerce, error) <span class="cov8" title="1">{
        args := m.Called(ctx, id)
        return args.Get(0).(*aggregation.Ecommerce), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package order

import (
        "context"
        "errors"
        customTracer "github.com/kizmey/order_management_system/observability/tracer"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        _orderRepository "github.com/kizmey/order_management_system/pkg/repository/order"
        _stockRepository "github.com/kizmey/order_management_system/pkg/repository/stock"
        _transactionRepository "github.com/kizmey/order_management_system/pkg/repository/transaction"
)

type orderServiceImpl struct {
        orderRepository       _orderRepository.OrderRepository
        transactionRepository _transactionRepository.TransactionRepository
        stockRepository       _stockRepository.StockRepository
}

func NewOrderServiceImpl(orderRepository _orderRepository.OrderRepository,
        transactionRepository _transactionRepository.TransactionRepository,
        stockRepository _stockRepository.StockRepository,
) OrderService <span class="cov8" title="1">{
        return &amp;orderServiceImpl{
                orderRepository:       orderRepository,
                transactionRepository: transactionRepository,
                stockRepository:       stockRepository,
        }
}</span>

func (s *orderServiceImpl) Create(ctx context.Context, order *entities.Order) (*entities.Order, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "orderCreateService")
        defer sp.End()

        newOrder, err := s.orderRepository.Create(ctx, order)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ecommerce, err := s.transactionRepository.FindProductsByTransactionID(ctx, order.TransactionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if ecommerce.Quantity == nil </span><span class="cov8" title="1">{
                return nil, errors.New("quantity is nil")
        }</span>

        <span class="cov8" title="1">stockRollback := make([]entities.Stock, 0)
        for i, product := range ecommerce.Product </span><span class="cov8" title="1">{
                quantityProduct := ecommerce.Quantity[i]

                stock, err := s.stockRepository.CheckStockByProductId(ctx, product.ProductID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">stock.Quantity -= quantityProduct

                stock, err = s.stockRepository.Update(ctx, stock.StockID, stock)
                if err != nil </span><span class="cov8" title="1">{
                        //for rollback
                        _, _ = s.orderRepository.Delete(ctx, newOrder.OrderID)
                        for _, rollback := range stockRollback </span><span class="cov0" title="0">{
                                _, _ = s.stockRepository.Update(ctx, rollback.StockID, &amp;rollback)
                        }</span>
                        <span class="cov8" title="1">return nil, err</span>
                }
                <span class="cov8" title="1">stock.Quantity += quantityProduct
                stockRollback = append(stockRollback, *stock)</span>
        }
        <span class="cov8" title="1">customTracer.SetSubAttributesWithJson(newOrder, sp)
        return newOrder, nil</span>
}

func (s *orderServiceImpl) FindAll(ctx context.Context) (*[]entities.Order, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "orderFindAllService")
        defer sp.End()

        orders, err := s.orderRepository.FindAll(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return orders, nil</span>
}

func (s *orderServiceImpl) FindByID(ctx context.Context, id string) (*entities.Order, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "orderFindByIdService")
        defer sp.End()

        order, err := s.orderRepository.FindByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return order, nil</span>
}

func (s *orderServiceImpl) Update(ctx context.Context, id string, order *entities.Order) (*entities.Order, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "orderUpdateService")
        defer sp.End()

        newOrder, err := s.orderRepository.Update(ctx, id, order)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ecommerce, err := s.transactionRepository.FindProductsByTransactionID(ctx, order.TransactionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if ecommerce.Quantity == nil </span><span class="cov8" title="1">{
                return nil, errors.New("quantity is nil")
        }</span>

        <span class="cov8" title="1">stockRollback := make([]entities.Stock, 0)
        for i, product := range ecommerce.Product </span><span class="cov8" title="1">{
                quantityProduct := ecommerce.Quantity[i]

                stock, err := s.stockRepository.CheckStockByProductId(ctx, product.ProductID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">stock.Quantity -= quantityProduct

                stock, err = s.stockRepository.Update(ctx, stock.StockID, stock)
                if err != nil </span><span class="cov8" title="1">{
                        _, _ = s.orderRepository.Delete(ctx, newOrder.OrderID)
                        for _, rollback := range stockRollback </span><span class="cov0" title="0">{
                                _, _ = s.stockRepository.Update(ctx, rollback.StockID, &amp;rollback)
                        }</span>
                        <span class="cov8" title="1">return nil, err</span>
                }
                <span class="cov8" title="1">stock.Quantity += quantityProduct
                stockRollback = append(stockRollback, *stock)</span>
        }

        <span class="cov8" title="1">return newOrder, nil</span>
}

func (s *orderServiceImpl) Delete(ctx context.Context, id string) (*entities.Order, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "orderDeleteService")
        defer sp.End()

        order, err := s.orderRepository.Delete(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return order, err</span>
}

func (s *orderServiceImpl) ChangeStatusNext(ctx context.Context, id string) (*entities.Order, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "orderChangeStatusNextService")
        defer sp.End()

        order, err := s.orderRepository.FindByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = order.NextStatus()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = s.orderRepository.UpdateStatus(ctx, id, order)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return order, nil</span>
}
func (s *orderServiceImpl) ChageStatusDone(ctx context.Context, id string) (*entities.Order, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "orderChageStatusDoneService")
        defer sp.End()

        order, err := s.orderRepository.FindByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = order.NextPaidToDone()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = s.orderRepository.UpdateStatus(ctx, id, order)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return order, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package product

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        _ProductRepository "github.com/kizmey/order_management_system/pkg/repository/product"
)

type productServiceImpl struct {
        productRepository _ProductRepository.ProductRepository
}

func NewProductServiceImpl(productRepository _ProductRepository.ProductRepository) ProductService <span class="cov8" title="1">{
        return &amp;productServiceImpl{productRepository: productRepository}
}</span>

func (s *productServiceImpl) Create(ctx context.Context, product *entities.Product) (*entities.Product, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "productCreateService")
        defer sp.End()

        productEntity, err := s.productRepository.Create(ctx, product)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return productEntity, nil</span>
}

func (s *productServiceImpl) FindAll(ctx context.Context) (*[]entities.Product, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "productFindAllService")
        defer sp.End()

        products, err := s.productRepository.FindAll(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return products, nil</span>
}

func (s *productServiceImpl) FindByID(ctx context.Context, id string) (*entities.Product, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "productFindByIdService")
        defer sp.End()

        product, err := s.productRepository.FindByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return product, nil</span>
}
func (s *productServiceImpl) Update(ctx context.Context, id string, product *entities.Product) (*entities.Product, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "productUpdateService")
        defer sp.End()

        productEntity, err := s.productRepository.Update(ctx, id, product)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return productEntity, nil</span>
}

func (s *productServiceImpl) Delete(ctx context.Context, id string) (*entities.Product, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "")
        defer sp.End()

        product, err := s.productRepository.Delete(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return product, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package stock

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        _StockRepository "github.com/kizmey/order_management_system/pkg/repository/stock"
)

type stockServiceImpl struct {
        stockRepository _StockRepository.StockRepository
}

func NewStockServiceImpl(stockRepository _StockRepository.StockRepository) StockService <span class="cov8" title="1">{
        return &amp;stockServiceImpl{stockRepository: stockRepository}
}</span>

func (s *stockServiceImpl) Create(ctx context.Context, stock *entities.Stock) (*entities.Stock, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "stockCreateService")
        defer sp.End()

        stockEntity, err := s.stockRepository.Create(ctx, stock)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return stockEntity, nil</span>
}

func (s *stockServiceImpl) FindAll(ctx context.Context) (*[]entities.Stock, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "stockFindAllService")
        defer sp.End()

        stockEntities, err := s.stockRepository.FindAll(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stockEntities, nil</span>
}

func (s *stockServiceImpl) CheckStockByProductId(ctx context.Context, id string) (*entities.Stock, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "stockCheckStockByProductIdService")
        defer sp.End()

        stock, err := s.stockRepository.CheckStockByProductId(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return stock, nil</span>
}

func (s *stockServiceImpl) Update(ctx context.Context, id string, stock *entities.Stock) (*entities.Stock, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "stockUpdateService")
        defer sp.End()

        stockEntity, err := s.stockRepository.Update(ctx, id, stock)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return stockEntity, nil</span>
}

func (s *stockServiceImpl) Delete(ctx context.Context, id string) (*entities.Stock, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "stockDeleteService")
        defer sp.End()

        stock, err := s.stockRepository.Delete(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stock, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package transaction

import (
        "context"
        "github.com/kizmey/order_management_system/pkg/interface/aggregation"
        "github.com/kizmey/order_management_system/pkg/interface/entities"
        _productRepository "github.com/kizmey/order_management_system/pkg/repository/product"
        _transactionRepository "github.com/kizmey/order_management_system/pkg/repository/transaction"
)

type transactionService struct {
        transactionRepository _transactionRepository.TransactionRepository
        productRepository     _productRepository.ProductRepository
}

func NewTransactionServiceImpl(
        transactionRepository _transactionRepository.TransactionRepository,
        productRepository _productRepository.ProductRepository,
) TransactionService <span class="cov8" title="1">{
        return &amp;transactionService{
                transactionRepository: transactionRepository,
                productRepository:     productRepository,
        }
}</span>

func (s *transactionService) Create(ctx context.Context, transaction *aggregation.TransactionEcommerce,
) (*aggregation.TransactionEcommerce, error) <span class="cov8" title="1">{

        ctx, sp := tracer.Start(ctx, "transactionCreateService")
        defer sp.End()

        for productID := range transaction.AddessProduct </span><span class="cov8" title="1">{
                product, err := s.productRepository.FindByID(ctx, productID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">transaction.Product = append(transaction.Product, *product)</span>
        }

        <span class="cov8" title="1">transaction.CalculatePrice()

        transactionEntity, err := s.transactionRepository.Create(ctx, transaction)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">transaction.Tranasaction = transactionEntity
        return transaction, nil</span>
}

func (s *transactionService) FindAll(ctx context.Context) (*[]entities.Transaction, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "transactionFindAllService")
        defer sp.End()

        transactionEntities, err := s.transactionRepository.FindAll(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return transactionEntities, nil</span>
}

func (s *transactionService) FindByID(ctx context.Context, id string) (*entities.Transaction, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "transactionFindByIdService")
        defer sp.End()

        transactionEntity, err := s.transactionRepository.FindByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return transactionEntity, nil</span>
}

func (s *transactionService) Update(ctx context.Context, id string, transaction *aggregation.TransactionEcommerce,
) (*aggregation.TransactionEcommerce, error) <span class="cov8" title="1">{

        ctx, sp := tracer.Start(ctx, "transactionUpdateService")
        defer sp.End()

        for productID := range transaction.AddessProduct </span><span class="cov8" title="1">{
                product, err := s.productRepository.FindByID(ctx, productID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">transaction.Product = append(transaction.Product, *product)</span>
        }

        <span class="cov8" title="1">transaction.CalculatePrice()

        transactionEntity, err := s.transactionRepository.Update(ctx, id, transaction)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">transaction.Tranasaction = transactionEntity
        return transaction, nil</span>
}

func (s *transactionService) Delete(ctx context.Context, id string) (*entities.Transaction, error) <span class="cov8" title="1">{
        ctx, sp := tracer.Start(ctx, "transactionDeleteService")
        defer sp.End()

        transaction, err := s.transactionRepository.Delete(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return transaction, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package pkg

import (
        "github.com/kizmey/order_management_system/database"
        "github.com/kizmey/order_management_system/pkg/repository/order"
        "github.com/kizmey/order_management_system/pkg/repository/product"
        "github.com/kizmey/order_management_system/pkg/repository/stock"
        "github.com/kizmey/order_management_system/pkg/repository/transaction"
        order2 "github.com/kizmey/order_management_system/pkg/service/order"
        product2 "github.com/kizmey/order_management_system/pkg/service/product"
        stock2 "github.com/kizmey/order_management_system/pkg/service/stock"
        transaction2 "github.com/kizmey/order_management_system/pkg/service/transaction"
)

type Usecase struct {
        TransactionService transaction2.TransactionService
        StockService       stock2.StockService
        ProductService     product2.ProductService
        OrderService       order2.OrderService
}

func NewUsecase(
        transactionService transaction2.TransactionService,
        stockService stock2.StockService,
        productService product2.ProductService,
        orderService order2.OrderService,
) *Usecase <span class="cov0" title="0">{
        return &amp;Usecase{
                TransactionService: transactionService,
                StockService:       stockService,
                ProductService:     productService,
                OrderService:       orderService,
        }
}</span>

func InitUsecase(db database.Database) *Usecase <span class="cov0" title="0">{

        // Init Repository

        orderRepo := order.NewOrderRepositoryImpl(db)
        productRepo := product.NewProductRepositoryImpl(db)
        stockRepo := stock.NewStockRepositoryImpl(db)
        transactionRepo := transaction.NewTransactionRepositoryImpl(db)

        // Init Service
        productService := product2.NewProductServiceImpl(productRepo)
        stockService := stock2.NewStockServiceImpl(stockRepo)
        transactionService := transaction2.NewTransactionServiceImpl(transactionRepo, productRepo)
        orderService := order2.NewOrderServiceImpl(orderRepo, transactionRepo, stockRepo)

        usecases := NewUsecase(transactionService, stockService, productService, orderService)

        return usecases
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package custom

import (
        "github.com/labstack/echo/v4"
)

type ErrorMessage struct {
        ErrorCode int    `json:"ErrorCode"`
        Message   string `json:"Error"`
}

func Error(c echo.Context, statusCode int, err ErrorStatus) error <span class="cov0" title="0">{
        return c.JSON(
                statusCode,
                ErrorMessage{
                        ErrorCode: err.Code,
                        Message:   err.Message,
                },
        )
}</span>

type ErrorStatus struct {
        Code    int
        Message string
}

var (
        //ErrInvalidRequest = ErrorStatus{Code: 1001, Message: "Invalid request data"}

        ErrOrderNotFound                = ErrorStatus{Code: 1002, Message: "Order not found"}
        ErrFailedToCreateOrder          = ErrorStatus{Code: 1003, Message: "Failed to create order"}
        ErrFailedToUpdateOrder          = ErrorStatus{Code: 1004, Message: "Failed to update order"}
        ErrFailedToDeleteOrder          = ErrorStatus{Code: 1005, Message: "Failed to delete order"}
        ErrFailedToRetrieveOrders       = ErrorStatus{Code: 1006, Message: "Failed to retrieve orders"}
        ErrFailedToChangeOrderStatus    = ErrorStatus{Code: 1007, Message: "Failed to change order status"}
        ErrFailedToValidateOrderRequest = ErrorStatus{Code: 1008, Message: "Failed to validate order request"}

        ErrFailedToCreateProduct          = ErrorStatus{Code: 2001, Message: "Failed to create product"}
        ErrFailedToUpdateProduct          = ErrorStatus{Code: 2002, Message: "Failed to update product"}
        ErrFailedToDeleteProduct          = ErrorStatus{Code: 2003, Message: "Failed to delete product"}
        ErrFailedToRetrieveProducts       = ErrorStatus{Code: 2004, Message: "Failed to retrieve products"}
        ErrProductNotFound                = ErrorStatus{Code: 2005, Message: "Product not found"}
        ErrFailedToValidateProductRequest = ErrorStatus{Code: 2006, Message: "Failed to validate product request"}

        ErrFailedToCreateStock          = ErrorStatus{Code: 3001, Message: "Failed to create stock"}
        ErrFailedToUpdateStock          = ErrorStatus{Code: 3002, Message: "Failed to update stock"}
        ErrFailedToDeleteStock          = ErrorStatus{Code: 3003, Message: "Failed to delete stock"}
        ErrFailedToRetrieveStocks       = ErrorStatus{Code: 3004, Message: "Failed to retrieve stocks"}
        ErrStockNotFound                = ErrorStatus{Code: 3005, Message: "Stock not found"}
        ErrFailedToValidateStockRequest = ErrorStatus{Code: 3006, Message: "Failed to validate stock request"}

        ErrFailedToCreateTransaction          = ErrorStatus{Code: 4001, Message: "Failed to create transaction"}
        ErrFailedToUpdateTransaction          = ErrorStatus{Code: 4002, Message: "Failed to update transaction"}
        ErrFailedToDeleteTransaction          = ErrorStatus{Code: 4003, Message: "Failed to delete transaction"}
        ErrFailedToRetrieveTransactions       = ErrorStatus{Code: 4004, Message: "Failed to retrieve transactions"}
        ErrTransactionNotFound                = ErrorStatus{Code: 4005, Message: "Transaction not found"}
        ErrFailedToValidateTransactionRequest = ErrorStatus{Code: 4006, Message: "Failed to validate transaction request"}
)

//var (
//        ErrInvalidRequest               = errors.New("1001: Invalid request data")
//        ErrOrderNotFound                = errors.New("1002: Order not found")
//        ErrFailedToCreateOrder          = errors.New("1003: Failed to create order")
//        ErrFailedToUpdateOrder          = errors.New("1004: Failed to update order")
//        ErrFailedToDeleteOrder          = errors.New("1005: Failed to delete order")
//        ErrFailedToRetrieveOrders       = errors.New("1006: Failed to retrieve orders")
//        ErrFailedToChangeOrderStatus    = errors.New("1007: Failed to change order status")
//        ErrFailedToValidateOrderRequest = errors.New("1008: Failed to validate order request")
//
//        ErrFailedToCreateProduct          = errors.New("2001: Failed to create product")
//        ErrFailedToUpdateProduct          = errors.New("2002: Failed to update product")
//        ErrFailedToDeleteProduct          = errors.New("2003: Failed to delete product")
//        ErrFailedToRetrieveProducts       = errors.New("2004: Failed to retrieve products")
//        ErrProductNotFound                = errors.New("2005: Product not found")
//        ErrFailedToValidateProductRequest = errors.New("2006: Failed to validate product request")
//
//        ErrFailedToCreateStock          = errors.New("3001: Failed to create stock")
//        ErrFailedToUpdateStock          = errors.New("3002: Failed to update stock")
//        ErrFailedToDeleteStock          = errors.New("3003: Failed to delete stock")
//        ErrFailedToRetrieveStocks       = errors.New("3004: Failed to retrieve stocks")
//        ErrStockNotFound                = errors.New("3005: Stock not found")
//        ErrFailedToValidateStockRequest = errors.New("3006: Failed to validate stock request")
//
//        ErrFailedToCreateTransaction          = errors.New("4001: Failed to create transaction")
//        ErrFailedToUpdateTransaction          = errors.New("4002: Failed to update transaction")
//        ErrFailedToDeleteTransaction          = errors.New("4003: Failed to delete transaction")
//        ErrFailedToRetrieveTransactions       = errors.New("4004: Failed to retrieve transactions")
//        ErrTransactionNotFound                = errors.New("4005: Transaction not found")
//        ErrFailedToValidateTransactionRequest = errors.New("4006: Failed to validate transaction request")
//)
</pre>
		
		<pre class="file" id="file32" style="display: none">package custom

import (
        "errors"
        "fmt"
        "github.com/labstack/echo/v4"
        "strconv"
)

func CheckParamId(echoRequest echo.Context) (uint64, error) <span class="cov0" title="0">{
        paramid := echoRequest.Param("id")
        //check error
        if paramid == "done/" </span><span class="cov0" title="0">{
                return 0, errors.New("param id not found")

        }</span>

        <span class="cov0" title="0">id, err := strconv.ParseUint(paramid, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New(fmt.Sprintf("param is not number : %s", err.Error()))
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package custom

import (
        "errors"
        "fmt"
        "sync"

        "github.com/go-playground/validator/v10"
        "github.com/labstack/echo/v4"
)

type EchoRequest interface {
        BindAndValidate(obj any) error
}

type customEchoRequest struct {
        ctx       echo.Context
        validator *validator.Validate
}

var (
        once              sync.Once
        validatorInstance *validator.Validate
)

func NewCustomEchoRequest(echoRequest echo.Context) EchoRequest <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                validatorInstance = validator.New()
        }</span>)

        <span class="cov0" title="0">return &amp;customEchoRequest{
                ctx:       echoRequest,
                validator: validatorInstance,
        }</span>
}

func (r *customEchoRequest) BindAndValidate(obj any) error <span class="cov0" title="0">{

        if err := r.ctx.Bind(obj); err != nil </span><span class="cov0" title="0">{
                //fmt.Errorf("invalid validate request : %s", err.Error())
                return errors.New(fmt.Sprintf("invalid request "))
        }</span>
        <span class="cov0" title="0">if err := r.validator.Struct(obj); err != nil </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("invalid validate request "))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package httpEchoServer

import (
        "context"
        "fmt"
        "github.com/kizmey/order_management_system/config"
        "github.com/kizmey/order_management_system/observability"
        "github.com/kizmey/order_management_system/pkg"
        "github.com/kizmey/order_management_system/server"
        customMiddleware "github.com/kizmey/order_management_system/server/httpEchoServer/middleware"
        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
        "github.com/labstack/gommon/log"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "net/http"
        "os"
        "os/signal"
        "syscall"
)

type echoServer struct {
        app     *echo.Echo
        conf    *config.Config
        usecase *pkg.Usecase
}

func NewEchoServer(conf *config.Config, usecase *pkg.Usecase) server.Server <span class="cov0" title="0">{
        echoApp := echo.New()
        echoApp.Logger.SetLevel(log.DEBUG)

        serverEcho := &amp;echoServer{
                app:     echoApp,
                conf:    conf,
                usecase: usecase,
        }

        observability.InitMetrics()

        return serverEcho
}</span>

func (s *echoServer) Start() <span class="cov0" title="0">{
        s.app.GET("/v1/health", s.healthCheck)
        s.app.GET("/metricsx", echo.WrapHandler(promhttp.Handler()))

        s.app.Use(middleware.Recover())
        s.app.Use(middleware.Logger())

        s.app.Use(customMiddleware.LoggerMiddleware)
        s.app.Use(customMiddleware.TracingMiddleware)

        //s.app.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
        //        Output: logger.LogFile,
        //}))

        s.initStockRouter()
        s.initProductRouter()
        s.initOrderRouter()
        s.inittransactionRouter()

        // Graceful shutdown
        quitCh := make(chan os.Signal, 1)
        signal.Notify(quitCh, syscall.SIGINT, syscall.SIGTERM)
        go s.gracefullyShutdown(quitCh)

        s.httpListening()
}</span>

func (s *echoServer) gracefullyShutdown(quitCh &lt;-chan os.Signal) <span class="cov0" title="0">{
        ctx := context.Background()

        &lt;-quitCh
        s.app.Logger.Infof("Shutting down service...")

        if err := s.app.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                s.app.Logger.Fatalf("Error: %s", err.Error())
        }</span>
}

func (s *echoServer) httpListening() <span class="cov0" title="0">{
        Url := fmt.Sprintf(":%d", s.conf.Server.Port)

        err := s.app.Start(Url)

        if err != nil </span><span class="cov0" title="0">{
                s.app.Logger.Fatalf("Error: %s", err.Error())
        }</span>
}

// path : /v1/health method : GET FOR check server
func (s *echoServer) healthCheck(c echo.Context) error <span class="cov0" title="0">{
        return c.String(http.StatusOK, "OK")
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package customMiddleware

import (
        logger "github.com/kizmey/order_management_system/observability/logs"
        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
        "time"
)

func LoggerMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{

                if c.Path() == "/metrics" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">start := time.Now()

                fields := logrus.Fields{
                        "method":   c.Request().Method,
                        "path":     c.Path(),
                        "query":    c.QueryString(),
                        "remoteIP": c.RealIP(),
                }

                // Log HTTP request
                //logger.LogInfo("HTTP request", fields)

                if err := next(c); err != nil </span><span class="cov0" title="0">{
                        c.Error(err)
                }</span>

                // Log HTTP response
                <span class="cov0" title="0">fields["status"] = c.Response().Status
                fields["latency"] = time.Since(start).Seconds()

                logger.LogInfo("HTTP response", fields)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package customMiddleware

import (
        "fmt"
        "github.com/labstack/echo/v4"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/propagation"
        semconv "go.opentelemetry.io/otel/semconv/v1.21.0"
        "go.opentelemetry.io/otel/trace"
)

var Tracer = otel.GetTracerProvider().Tracer("echo-server")

func TracingMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                // Create a carrier to extract context
                carrier := propagation.HeaderCarrier(c.Request().Header)
                ctx := otel.GetTextMapPropagator().Extract(c.Request().Context(), carrier)

                // Define span options
                spanOptions := []trace.SpanStartOption{
                        trace.WithAttributes(semconv.HTTPMethodKey.String(c.Request().Method)),
                        trace.WithAttributes(semconv.HTTPTargetKey.String(c.Path())),
                        trace.WithAttributes(semconv.HTTPRouteKey.String(c.Path())),
                        trace.WithAttributes(semconv.HTTPURLKey.String(fmt.Sprintf("%s://%s%s", c.Scheme(), c.Request().Host, c.Request().RequestURI))),
                        trace.WithAttributes(semconv.UserAgentOriginal(c.Request().UserAgent())),
                        trace.WithAttributes(semconv.HTTPRequestContentLengthKey.Int64(c.Request().ContentLength)),
                        trace.WithAttributes(semconv.HTTPSchemeKey.String(c.Scheme())),
                        trace.WithAttributes(semconv.NetTransportTCP),
                        trace.WithSpanKind(trace.SpanKindServer),
                }

                // Start a new span with the extracted context and options
                ctx, span := Tracer.Start(ctx, c.Request().Method+" "+c.Path(), spanOptions...)
                defer span.End()

                // Set the context with the new span in the request
                c.SetRequest(c.Request().WithContext(ctx))

                // Proceed to the next middleware/handler
                if err := next(c); err != nil </span><span class="cov0" title="0">{
                        c.Error(err)
                }</span>

                // Inject headers back into response
                <span class="cov0" title="0">propagator := otel.GetTextMapPropagator()
                carrier = propagation.HeaderCarrier{}
                propagator.Inject(ctx, carrier)

                for _, k := range carrier.Keys() </span><span class="cov0" title="0">{
                        c.Response().Header().Set(k, carrier.Get(k))
                }</span>

                // Set HTTP status code in span attributes
                <span class="cov0" title="0">span.SetAttributes(semconv.HTTPStatusCodeKey.Int(c.Response().Status))
                return nil</span>
        }
}

//package customMiddleware
//
//import (
//"fmt"
//"github.com/labstack/echo/v4"
//"go.opentelemetry.io/tracer"
//"go.opentelemetry.io/tracer/propagation"
//semconv "go.opentelemetry.io/tracer/semconv/v1.21.0"
//"go.opentelemetry.io/tracer/trace"
//)
//
//var Tracer = tracer.GetTracerProvider().Tracer("echo-server")
//
//func TracingMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
//        return func(c echo.Context) error {
//                propagator := propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{})
//                carrier := propagation.HeaderCarrier{}
//
//                // Extract headers from Echo Context and inject into carrier
//                contentType := c.Request().Header.Get(echo.HeaderContentType)
//                carrier.Set(echo.HeaderContentType, contentType)
//
//                // Inject propagated headers into context
//                propagator.Inject(c.Request().Context(), carrier)
//
//                // Define span options
//                spanOptions := []trace.SpanStartOption{
//                        trace.WithAttributes(semconv.HTTPMethodKey.String(c.Request().Method)),
//                        trace.WithAttributes(semconv.HTTPTargetKey.String(c.Path())),
//                        trace.WithAttributes(semconv.HTTPRouteKey.String(c.Path())),
//                        trace.WithAttributes(semconv.HTTPURLKey.String(fmt.Sprintf("%s://%s%s", c.Scheme(), c.Request().Host, c.Request().RequestURI))),
//                        trace.WithAttributes(semconv.UserAgentOriginal(c.Request().UserAgent())),
//                        trace.WithAttributes(semconv.HTTPRequestContentLengthKey.Int64(c.Request().ContentLength)),
//                        trace.WithAttributes(semconv.HTTPSchemeKey.String(c.Scheme())),
//                        trace.WithAttributes(semconv.NetTransportTCP),
//                        trace.WithSpanKind(trace.SpanKindServer),
//                }
//
//                // Start a new span for tracing
//                ctx, span := Tracer.Start(c.Request().Context(), fmt.Sprintf("%s %s", c.Request().Method, c.Path()), spanOptions...)
//                defer span.End()
//
//                // Inject headers back into response
//                {
//                        propagator := propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{})
//                        carrier := propagation.HeaderCarrier{}
//                        propagator.Inject(ctx, carrier)
//
//                        for _, k := range carrier.Keys() {
//                                c.Response().Header().Set(k, carrier.Get(k))
//                        }
//                }
//
//                // Debugging - Print the Trace ID in middleware
//                traceID := trace.SpanContextFromContext(c.Request().Context()).TraceID()
//                fmt.Println("Trace ID: ", traceID)
//
//                // Proceed to the next middleware/handler
//                if err := next(c); err != nil {
//                        c.Error(err)
//                }
//
//                // Set HTTP status code in span attributes
//                span.SetAttributes(semconv.HTTPStatusCodeKey.Int(c.Response().Status))
//                return nil
//        }
//}
</pre>
		
		<pre class="file" id="file37" style="display: none">package httpEchoServer

import (
        _orderController "github.com/kizmey/order_management_system/pkg/controller/order"
)

func (s *echoServer) initOrderRouter() <span class="cov0" title="0">{
        router := s.app.Group("/v1/order")

        orderController := _orderController.NewOrderControllerImpl(s.usecase.OrderService)

        router.POST("", orderController.Create)
        router.GET("", orderController.FindAll)
        router.GET("/:id", orderController.FindByID)
        router.PUT("/:id", orderController.Update)
        router.DELETE("/:id", orderController.Delete)
        router.PUT("/next/:id", orderController.ChangeStatusNext)
        router.PUT("/done/:id", orderController.ChageStatusDone)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package httpEchoServer

import (
        _productController "github.com/kizmey/order_management_system/pkg/controller/product"
)

func (s *echoServer) initProductRouter() <span class="cov0" title="0">{
        router := s.app.Group("/v1/product")

        productController := _productController.NewProductControllerImpl(s.usecase.ProductService)

        router.POST("", productController.Create)
        router.GET("", productController.FindAll)
        router.GET("/:id", productController.FindByID)
        router.PUT("/:id", productController.Update)
        router.DELETE("/:id", productController.Delete)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package httpEchoServer

import (
        _stockController "github.com/kizmey/order_management_system/pkg/controller/stock"
)

func (s *echoServer) initStockRouter() <span class="cov0" title="0">{
        router := s.app.Group("/v1/stock")

        stockController := _stockController.NewStockControllerImpl(s.usecase.StockService)

        router.GET("", stockController.FindAll)
        router.GET("/product/:id", stockController.CheckStockByProductId)
        router.POST("", stockController.Create)
        router.PUT("/:id", stockController.Update)
        router.DELETE("/:id", stockController.Delete)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package httpEchoServer

import (
        _transactionController "github.com/kizmey/order_management_system/pkg/controller/transaction"
)

func (s *echoServer) inittransactionRouter() <span class="cov0" title="0">{
        router := s.app.Group("/v1/transaction")

        transactionController := _transactionController.NewTransactionControllerImpl(s.usecase.TransactionService)

        router.POST("", transactionController.Create)
        router.GET("", transactionController.FindAll)
        router.GET("/:id", transactionController.FindByID)
        router.PUT("/:id", transactionController.Update)
        router.DELETE("/:id", transactionController.Delete)

}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
